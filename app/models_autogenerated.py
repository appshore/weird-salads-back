"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class StaffDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]
    dob: typing.Optional[str]
    role: typing.Optional["RoleDict"]
    iban: typing.Optional[str]
    bic: typing.Optional[str]


class TStaff(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Staff.
        name: The name of the Staff.
        dob: The dob of the Staff.
        role: The role of the Staff.
        iban: The iban of the Staff.
        bic: The bic of the Staff.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'
    dob: 'sqlalchemy.Column[typing.Optional[str]]'
    role: 'sqlalchemy.Column[typing.Optional["TRole"]]'
    iban: 'sqlalchemy.Column[typing.Optional[str]]'
    bic: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None, dob: typing.Optional[str] = None, role: typing.Optional["TRole"] = None, iban: typing.Optional[str] = None, bic: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Staff.
            name: The name of the Staff.
            dob: The dob of the Staff.
            role: The role of the Staff.
            iban: The iban of the Staff.
            bic: The bic of the Staff.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None, dob: typing.Optional[str] = None, role: typing.Optional["RoleDict"] = None, iban: typing.Optional[str] = None, bic: typing.Optional[str] = None) -> "TStaff":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Staff.
            name: The name of the Staff.
            dob: The dob of the Staff.
            role: The role of the Staff.
            iban: The iban of the Staff.
            bic: The bic of the Staff.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TStaff":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> StaffDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Staff: typing.Type[TStaff] = models.Staff  # type: ignore


class RoleDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]


class TRole(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Role.
        name: The name of the Role.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Role.
            name: The name of the Role.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None) -> "TRole":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Role.
            name: The name of the Role.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TRole":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> RoleDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Role: typing.Type[TRole] = models.Role  # type: ignore


class LocationDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]
    address: typing.Optional[str]


class TLocation(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Location.
        name: The name of the Location.
        address: The address of the Location.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'
    address: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None, address: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Location.
            name: The name of the Location.
            address: The address of the Location.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None, address: typing.Optional[str] = None) -> "TLocation":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Location.
            name: The name of the Location.
            address: The address of the Location.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TLocation":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> LocationDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Location: typing.Type[TLocation] = models.Location  # type: ignore


class IngredientDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]
    unit: typing.Optional[str]
    cost: typing.Optional[float]


class TIngredient(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Ingredient.
        name: The name of the Ingredient.
        unit: The unit of the Ingredient.
        cost: The cost of the Ingredient.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'
    unit: 'sqlalchemy.Column[typing.Optional[str]]'
    cost: 'sqlalchemy.Column[typing.Optional[float]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None, unit: typing.Optional[str] = None, cost: typing.Optional[float] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Ingredient.
            name: The name of the Ingredient.
            unit: The unit of the Ingredient.
            cost: The cost of the Ingredient.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None, unit: typing.Optional[str] = None, cost: typing.Optional[float] = None) -> "TIngredient":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Ingredient.
            name: The name of the Ingredient.
            unit: The unit of the Ingredient.
            cost: The cost of the Ingredient.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TIngredient":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> IngredientDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Ingredient: typing.Type[TIngredient] = models.Ingredient  # type: ignore


class ModifierDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]
    option: typing.Optional[str]
    price: typing.Optional[float]


class TModifier(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Modifier.
        name: The name of the Modifier.
        option: The option of the Modifier.
        price: The price of the Modifier.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'
    option: 'sqlalchemy.Column[typing.Optional[str]]'
    price: 'sqlalchemy.Column[typing.Optional[float]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None, option: typing.Optional[str] = None, price: typing.Optional[float] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Modifier.
            name: The name of the Modifier.
            option: The option of the Modifier.
            price: The price of the Modifier.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None, option: typing.Optional[str] = None, price: typing.Optional[float] = None) -> "TModifier":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Modifier.
            name: The name of the Modifier.
            option: The option of the Modifier.
            price: The price of the Modifier.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TModifier":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> ModifierDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Modifier: typing.Type[TModifier] = models.Modifier  # type: ignore


class RecipeDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    name: typing.Optional[str]


class TRecipe(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Recipe.
        name: The name of the Recipe.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[typing.Optional[str]]'

    def __init__(self, id: typing.Optional[int] = None, name: typing.Optional[str] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Recipe.
            name: The name of the Recipe.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, name: typing.Optional[str] = None) -> "TRecipe":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Recipe.
            name: The name of the Recipe.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TRecipe":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> RecipeDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Recipe: typing.Type[TRecipe] = models.Recipe  # type: ignore


class MenuDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    recipe: typing.Optional["RecipeDict"]
    location: typing.Optional["LocationDict"]
    price: typing.Optional[float]


class TMenu(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Menu.
        recipe: The recipe of the Menu.
        location: The location of the Menu.
        price: The price of the Menu.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    recipe: 'sqlalchemy.Column[typing.Optional["TRecipe"]]'
    location: 'sqlalchemy.Column[typing.Optional["TLocation"]]'
    price: 'sqlalchemy.Column[typing.Optional[float]]'

    def __init__(self, id: typing.Optional[int] = None, recipe: typing.Optional["TRecipe"] = None, location: typing.Optional["TLocation"] = None, price: typing.Optional[float] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Menu.
            recipe: The recipe of the Menu.
            location: The location of the Menu.
            price: The price of the Menu.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, recipe: typing.Optional["RecipeDict"] = None, location: typing.Optional["LocationDict"] = None, price: typing.Optional[float] = None) -> "TMenu":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Menu.
            recipe: The recipe of the Menu.
            location: The location of the Menu.
            price: The price of the Menu.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TMenu":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> MenuDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Menu: typing.Type[TMenu] = models.Menu  # type: ignore
